#version 450

layout (local_size_x = 256) in;

layout(constant_id = 0) const uint count = 4;
const uint size = 500;
const float max_x = 100;
const float max_y = 60;
const float radius = 1.0;

layout(binding = 0, std430) buffer world_in{
  vec2 s[size];
  vec2 v[size];
  vec4 color[size];
};

void bounds_check(inout vec2 pos, inout vec2 vel) {
  if (pos.x + radius > max_x) {
    pos.x -= pos.x - max_x + radius;
    vel.x *= -1;
  } else if (pos.x < radius) {
    pos.x -= pos.x - radius;
    vel.x *= -1;
  }
  if (pos.y + radius > max_y) {
    pos.y -= pos.y - max_y + radius;
    vel.y *= -1;
  } else if (pos.y < radius) {
    pos.y -= pos.y - radius;
    vel.y *= -1;
  }
}

vec2 collision_check(uint a, uint b, out vec2 v_old[size]){
  if(distance(s[a], s[b]) < radius * 2){
    vec2 ds = s[a] - s[b];
    color[a].r = 0.8;
    return - dot(v[a] - v[b], ds) / dot(ds, ds) * ds;
  }
  color[a].r = 0.2;
  return v[a];
}

void main() {
  vec2 v_old[size] = v;
	uint id = gl_GlobalInvocationID.x;
  if(id < count){
    s[id] += v[id];
    bounds_check(s[id], v[id]);
  }
  if(id == 1 ){
    v_old[id] = collision_check(id, id - 1, v_old);
  }
  if(id == 0){
    v_old[id] = collision_check(id, id + 1, v_old);
  }
  barrier();
  if(id < count){
    v[id] = v_old[id];
  }
}